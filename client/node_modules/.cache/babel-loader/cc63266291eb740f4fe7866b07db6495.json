{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Ben\\\\Desktop\\\\John Bryce\\\\\\u05E4\\u05E8\\u05D5\\u05D9\\u05D9\\u05E7\\u05D8\\u05D9\\u05DD\\\\project3 - Vacations\\\\client\\\\src\\\\components\\\\favoriteVacations\\\\FavoriteVacations.tsx\";\nimport React, { Component } from 'react';\nimport axios from 'axios';\nimport { store } from '../../Redux/Store';\nimport { ActionType } from '../../Redux/ActionType';\nimport { withRouter } from 'react-router';\nimport { isUserLoggedValidator } from '../../models/IsUserLoggedValidator';\nimport { interceptorHandler } from '../../models/InterceptorHandler';\nimport FavoriteVacationComponent from '../vacationComponent/FavoriteVacationComponent';\nimport { getUserTypeFromStorage } from '../../models/GetUserTypeFromStorage';\nimport socketIOClient from \"socket.io-client\";\nimport './favoriteVacations.css'; // ------------------------------------------------- This Component Displays All The User's Favorite Vacations ------------------------------------------------- //\n\nexport class FavoriteVacations extends Component {\n  constructor(props) {\n    super(props);\n    this.unSubscribeStore = void 0;\n    this.socket = void 0;\n    this.userID = Math.floor(Math.random() * 10000);\n\n    this.componentWillUnmount = () => {\n      // Unsubscribing the store's listener right before the component will unmount\n      // In order to make a small optimization\n      this.unSubscribeStore();\n      const isUserLogged = isUserLoggedValidator();\n\n      if (isUserLogged) {\n        // Disconnecting from the socket connection\n        this.socket.emit('disconnect', this.userID);\n      }\n    };\n\n    this.componentDidMount = () => {\n      // Initiating the Socket connection to the server\n      this.initiateSocket(); // Explanation -> The interceptor is a just JS variable (from axios library). On refresh = it resets.\n      // So, this Model takes the token the user got from the server (which is now inside the sessionStorage),\n      // and assign it to the interceptor\n\n      interceptorHandler(); // Optimizing a bit the memory leak of the store listener\n      // Also subscribes automatically to the store\n\n      this.unSubscribeStore = store.subscribe(() => this.setState({\n        favoriteVacations: store.getState().favoriteVacations\n      })); // Checks whether the user's favorite vacations exist in the Global Store\n\n      this.checkIfGlobalStoreHasFavoriteVacations();\n    };\n\n    this.getFavoriteVacationsFromServer = async () => {\n      // Explanation -> 2 layers validation:\n      // Using a Model I made to check if the user is 'USER' type, and if so, attempt to fetch his favorite vacations.\n      // This validation happens again in the server, using the server's cache, to MAKE SURE he is indeed a 'USER' type.\n      // If the validation fails in the server, the request will not retrieve any favorite vacations.\n      // This validation happens to speed up proccesses and for better UX -> Not seding a request to the server if not absolutely necessary!\n      const userTypeFromStorage = getUserTypeFromStorage();\n\n      if (userTypeFromStorage === \"USER\") {\n        try {\n          // The response we get, should be type of 'Vacation' class\n          const response = await axios.get('http://localhost:3001/vacations/favorite_vacations'); // Here we are receiving all the user's favorite vacations from the server, as a JSON\n\n          const favoriteVacations = response.data; // Updating the Global Store\n\n          store.dispatch({\n            type: ActionType.GetFavoriteVacations,\n            payload: favoriteVacations\n          });\n        } catch (error) {\n          try {\n            let errorMessage = error.response.data.error;\n            this.favoriteVacationsErrorHandler(errorMessage);\n          } catch {\n            this.favoriteVacationsErrorHandler(error);\n          }\n        }\n      }\n    };\n\n    this.removeClickedVacationFromFavorites = async clickedVacationID => {\n      /*\r\n          Before unfollowing a vacation, checking if the user is currently logged in.\r\n          This validation happens because a user might delete his token before trying\r\n          to unfollow a vacation. In that case, throw him out to login again. -> Don't waste a server request on him.\r\n      */\n      // Using a Model I made to check if the user is still logged (Preventing duplication of code from all component that needs to make this validation).\n      const isUserLogged = isUserLoggedValidator();\n\n      if (isUserLogged) {\n        interceptorHandler();\n\n        try {\n          // The response we get, should be type of 'Vacation' class\n          await axios.post(`http://localhost:3001/vacations/unfollow_vacation/${clickedVacationID}`);\n          let indexOfClickedVacationInGlobalStore = this.getIndexOfFavoriteVacationByID(clickedVacationID); // Updating the Global Store. Sending the index of the vacation to the Reducer, in order to remove it from the global store\n\n          store.dispatch({\n            type: ActionType.UnfollowVacation,\n            payload: indexOfClickedVacationInGlobalStore\n          }); // Emitting a socket message to the server, in order to inform all clients about the new unfollowed vacation in the UI\n\n          this.socket.emit('decrease-vacation-followers-count', clickedVacationID);\n        } catch (error) {\n          let errorMessage = error.response.data.error;\n          this.favoriteVacationsErrorHandler(errorMessage);\n        }\n      } // In case a guest tried to follow a vacation, send him to the login page in order for him to login (a guest is not logged in)\n      else {\n          this.props.history.push('/login');\n        }\n    };\n\n    this.OnUserDislikeClick = (clickedVacation, event) => {\n      const button = event.target;\n      this.disableButton(button);\n      let clickedVacationID = clickedVacation.vacationID;\n      this.removeClickedVacationFromFavorites(clickedVacationID);\n      this.enableButton(button);\n    };\n\n    this.getIndexOfFavoriteVacationByID = vacationID => {\n      // Finding and returning the index of a vacation, by a given ID\n      let favoriteVacations = store.getState().favoriteVacations; // Finding the clicked vacation in the Global Store\n\n      let clickedVacationInGlobalStore = favoriteVacations.find(favoriteVacation => favoriteVacation.vacationID === vacationID);\n      let indexOfClickedVacationInGlobalStore = favoriteVacations.indexOf(clickedVacationInGlobalStore);\n      return indexOfClickedVacationInGlobalStore;\n    };\n\n    this.checkIfGlobalStoreHasFavoriteVacations = () => {\n      // If our favorite vacations state in the global store is empty, fetch the favorite vacations from the server and insert them to the global store\n      const favoriteVacationsInGlobalStore = store.getState().favoriteVacations;\n\n      if (favoriteVacationsInGlobalStore.length === 0) {\n        this.getFavoriteVacationsFromServer();\n      } // If we have the user's favorite vacations in the Global Store, fetch them instead of sending a request to the server\n      else {\n          this.setState({\n            favoriteVacations: favoriteVacationsInGlobalStore\n          });\n        }\n    };\n\n    this.initiateSocket = () => {\n      // Connecting to the server's Socket\n      this.socket = socketIOClient('http://localhost:3002', {\n        query: \"userID=\" + this.userID\n      });\n    };\n\n    this.disableButton = button => {\n      button.disabled = true;\n      button.style.cursor = \"not-allowed\";\n    };\n\n    this.enableButton = button => {\n      button.disabled = false;\n      button.style.cursor = \"pointer\";\n    };\n\n    this.favoriteVacationsErrorHandler = errorMessage => {\n      // Letting the user know he received an error, by displaying the error as a Popup message\n      let snackbar = document.getElementById(\"snackbar\");\n      snackbar.className = \"show\";\n      snackbar.textContent = errorMessage;\n      setTimeout(function () {\n        snackbar.className = snackbar.className.replace(\"show\", \"\");\n      }, 3000);\n    };\n\n    this.state = {\n      favoriteVacations: new Array()\n    };\n  } // ------------------------------------------------- Component Settings ------------------------------------------------- //\n\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 247,\n        columnNumber: 13\n      }\n    }, // --------- If the user has no favorite vacations --------- //\n    this.state.favoriteVacations.length > 0 && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"favoriteVacationsSection\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 253,\n        columnNumber: 25\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"headerContainer\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 255,\n        columnNumber: 29\n      }\n    }, /*#__PURE__*/React.createElement(\"h2\", {\n      className: \"sharp-text favoritesHeader\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 256,\n        columnNumber: 33\n      }\n    }, \"Your Favorite Vacations\")), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"favoriteVacations\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 259,\n        columnNumber: 29\n      }\n    }, this.state.favoriteVacations.map((vacation, index) => /*#__PURE__*/React.createElement(FavoriteVacationComponent, {\n      key: index,\n      vacation: vacation,\n      OnUserDislikeClick: this.OnUserDislikeClick,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 264,\n        columnNumber: 37\n      }\n    })))), /*#__PURE__*/React.createElement(\"div\", {\n      id: \"snackbar\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 271,\n        columnNumber: 17\n      }\n    }));\n  }\n\n}\nexport default withRouter(FavoriteVacations);","map":{"version":3,"sources":["C:/Users/Ben/Desktop/John Bryce/פרוייקטים/project3 - Vacations/client/src/components/favoriteVacations/FavoriteVacations.tsx"],"names":["React","Component","axios","store","ActionType","withRouter","isUserLoggedValidator","interceptorHandler","FavoriteVacationComponent","getUserTypeFromStorage","socketIOClient","FavoriteVacations","constructor","props","unSubscribeStore","socket","userID","Math","floor","random","componentWillUnmount","isUserLogged","emit","componentDidMount","initiateSocket","subscribe","setState","favoriteVacations","getState","checkIfGlobalStoreHasFavoriteVacations","getFavoriteVacationsFromServer","userTypeFromStorage","response","get","data","dispatch","type","GetFavoriteVacations","payload","error","errorMessage","favoriteVacationsErrorHandler","removeClickedVacationFromFavorites","clickedVacationID","post","indexOfClickedVacationInGlobalStore","getIndexOfFavoriteVacationByID","UnfollowVacation","history","push","OnUserDislikeClick","clickedVacation","event","button","target","disableButton","vacationID","enableButton","clickedVacationInGlobalStore","find","favoriteVacation","indexOf","favoriteVacationsInGlobalStore","length","query","disabled","style","cursor","snackbar","document","getElementById","className","textContent","setTimeout","replace","state","Array","render","map","vacation","index"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport axios from 'axios';\r\nimport Vacation from '../../models/Vacation';\r\nimport { store } from '../../Redux/Store';\r\nimport { Unsubscribe } from 'redux';\r\nimport { ActionType } from '../../Redux/ActionType';\r\nimport {withRouter} from 'react-router';\r\nimport { isUserLoggedValidator } from '../../models/IsUserLoggedValidator';\r\nimport { interceptorHandler } from '../../models/InterceptorHandler';\r\nimport FavoriteVacationComponent from '../vacationComponent/FavoriteVacationComponent';\r\nimport { getUserTypeFromStorage } from '../../models/GetUserTypeFromStorage';\r\nimport socketIOClient from \"socket.io-client\";\r\nimport './favoriteVacations.css';\r\n\r\n\r\n// ------------------------------------------------- This Component Displays All The User's Favorite Vacations ------------------------------------------------- //\r\n\r\ninterface VacationsState {\r\n    favoriteVacations : Vacation[];\r\n}\r\n\r\nexport class FavoriteVacations extends Component <any, VacationsState> {\r\n    \r\n    private unSubscribeStore : Unsubscribe;\r\n    private socket: any;\r\n    private userID = Math.floor(Math.random() * 10000);\r\n\r\n    constructor(props : any) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            favoriteVacations : new Array <Vacation> ()\r\n        }\r\n    }\r\n\r\n\r\n    // ------------------------------------------------- Component Settings ------------------------------------------------- //\r\n    \r\n    componentWillUnmount = () => {\r\n\r\n        // Unsubscribing the store's listener right before the component will unmount\r\n        // In order to make a small optimization\r\n        this.unSubscribeStore();\r\n\r\n        const isUserLogged = isUserLoggedValidator();\r\n\r\n        if (isUserLogged) {\r\n            // Disconnecting from the socket connection\r\n            this.socket.emit('disconnect', this.userID);\r\n        }\r\n    }\r\n\r\n    componentDidMount = () => {\r\n\r\n        // Initiating the Socket connection to the server\r\n        this.initiateSocket();\r\n\r\n        // Explanation -> The interceptor is a just JS variable (from axios library). On refresh = it resets.\r\n        // So, this Model takes the token the user got from the server (which is now inside the sessionStorage),\r\n        // and assign it to the interceptor\r\n        interceptorHandler();\r\n\r\n\r\n        // Optimizing a bit the memory leak of the store listener\r\n        // Also subscribes automatically to the store\r\n        this.unSubscribeStore = store.subscribe(\r\n            () => this.setState ({\r\n                favoriteVacations: store.getState().favoriteVacations\r\n            })\r\n        );\r\n\r\n        // Checks whether the user's favorite vacations exist in the Global Store\r\n        this.checkIfGlobalStoreHasFavoriteVacations();\r\n    }\r\n\r\n\r\n\r\n    // ------------------------------------------------- Model ------------------------------------------------- //\r\n\r\n    private getFavoriteVacationsFromServer = async () => {\r\n        \r\n        // Explanation -> 2 layers validation:\r\n        // Using a Model I made to check if the user is 'USER' type, and if so, attempt to fetch his favorite vacations.\r\n        // This validation happens again in the server, using the server's cache, to MAKE SURE he is indeed a 'USER' type.\r\n        // If the validation fails in the server, the request will not retrieve any favorite vacations.\r\n        // This validation happens to speed up proccesses and for better UX -> Not seding a request to the server if not absolutely necessary!\r\n        \r\n        const userTypeFromStorage = getUserTypeFromStorage();\r\n\r\n        if (userTypeFromStorage === \"USER\") {\r\n\r\n            try {\r\n\r\n                // The response we get, should be type of 'Vacation' class\r\n                const response = await axios.get<Vacation[]>('http://localhost:3001/vacations/favorite_vacations');\r\n                \r\n                // Here we are receiving all the user's favorite vacations from the server, as a JSON\r\n                const favoriteVacations : Vacation[] = response.data;\r\n    \r\n                // Updating the Global Store\r\n                store.dispatch({\r\n                    type: ActionType.GetFavoriteVacations,\r\n                    payload: favoriteVacations\r\n                });\r\n            }\r\n    \r\n            catch (error) {\r\n    \r\n                try {\r\n                    let errorMessage = error.response.data.error;\r\n                    this.favoriteVacationsErrorHandler(errorMessage);\r\n                }\r\n                catch {\r\n                    this.favoriteVacationsErrorHandler(error);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private removeClickedVacationFromFavorites = async (clickedVacationID : number) => {\r\n\r\n        /*\r\n            Before unfollowing a vacation, checking if the user is currently logged in.\r\n            This validation happens because a user might delete his token before trying\r\n            to unfollow a vacation. In that case, throw him out to login again. -> Don't waste a server request on him.\r\n        */\r\n\r\n        // Using a Model I made to check if the user is still logged (Preventing duplication of code from all component that needs to make this validation).\r\n\r\n        const isUserLogged = isUserLoggedValidator();\r\n\r\n        if (isUserLogged) {\r\n\r\n            interceptorHandler();\r\n\r\n            try {\r\n                // The response we get, should be type of 'Vacation' class\r\n                await axios.post(`http://localhost:3001/vacations/unfollow_vacation/${clickedVacationID}`);\r\n       \r\n                let indexOfClickedVacationInGlobalStore = this.getIndexOfFavoriteVacationByID(clickedVacationID);\r\n    \r\n                // Updating the Global Store. Sending the index of the vacation to the Reducer, in order to remove it from the global store\r\n                store.dispatch({\r\n                    type: ActionType.UnfollowVacation,\r\n                    payload: indexOfClickedVacationInGlobalStore\r\n                });\r\n                \r\n                // Emitting a socket message to the server, in order to inform all clients about the new unfollowed vacation in the UI\r\n                this.socket.emit('decrease-vacation-followers-count', clickedVacationID);\r\n            }\r\n    \r\n            catch (error) {\r\n                let errorMessage = error.response.data.error;\r\n                this.favoriteVacationsErrorHandler(errorMessage);\r\n            }\r\n        }\r\n\r\n\r\n        // In case a guest tried to follow a vacation, send him to the login page in order for him to login (a guest is not logged in)\r\n        else {\r\n            this.props.history.push('/login');\r\n        }\r\n    }\r\n\r\n\r\n\r\n    // ------------------------------------------------- Controller ------------------------------------------------- //\r\n\r\n    private OnUserDislikeClick = (clickedVacation : Vacation, event : MouseEvent) => {\r\n\r\n        const button = event.target as HTMLButtonElement;\r\n        this.disableButton(button);\r\n\r\n        let clickedVacationID: number = clickedVacation.vacationID;\r\n        this.removeClickedVacationFromFavorites(clickedVacationID);\r\n\r\n        this.enableButton(button);\r\n    }\r\n\r\n    private getIndexOfFavoriteVacationByID = (vacationID: number) => {\r\n\r\n        // Finding and returning the index of a vacation, by a given ID\r\n\r\n        let favoriteVacations: Vacation[] = store.getState().favoriteVacations as Vacation[];\r\n\r\n        // Finding the clicked vacation in the Global Store\r\n        let clickedVacationInGlobalStore: Vacation = favoriteVacations.find( favoriteVacation =>  favoriteVacation.vacationID === vacationID);\r\n        let indexOfClickedVacationInGlobalStore: number = favoriteVacations.indexOf(clickedVacationInGlobalStore);\r\n\r\n        return indexOfClickedVacationInGlobalStore\r\n    }\r\n\r\n    private checkIfGlobalStoreHasFavoriteVacations = () => {\r\n\r\n        // If our favorite vacations state in the global store is empty, fetch the favorite vacations from the server and insert them to the global store\r\n\r\n        const favoriteVacationsInGlobalStore = store.getState().favoriteVacations;\r\n\r\n        if (favoriteVacationsInGlobalStore.length === 0) {\r\n            this.getFavoriteVacationsFromServer();\r\n        }\r\n\r\n        // If we have the user's favorite vacations in the Global Store, fetch them instead of sending a request to the server\r\n        else {\r\n            this.setState ({\r\n                favoriteVacations: favoriteVacationsInGlobalStore\r\n            });\r\n        }\r\n    }\r\n\r\n    private initiateSocket = () => {\r\n\r\n        // Connecting to the server's Socket\r\n        this.socket = socketIOClient('http://localhost:3002', { query: \"userID=\" + this.userID });\r\n    }\r\n\r\n\r\n\r\n    // ------------------------------------------------- View ------------------------------------------------- //\r\n\r\n    private disableButton = (button : HTMLButtonElement) : void => {\r\n        button.disabled = true;\r\n        button.style.cursor = \"not-allowed\";\r\n    }\r\n\r\n    private enableButton = (button : HTMLButtonElement) : void => {\r\n        button.disabled = false;\r\n        button.style.cursor = \"pointer\";\r\n    }\r\n\r\n    private favoriteVacationsErrorHandler = (errorMessage: string) => {\r\n\r\n        // Letting the user know he received an error, by displaying the error as a Popup message\r\n\r\n        let snackbar: HTMLDivElement = document.getElementById(\"snackbar\") as HTMLDivElement;\r\n        snackbar.className = \"show\";\r\n        snackbar.textContent = errorMessage;\r\n\r\n        setTimeout(function() {\r\n            snackbar.className = snackbar.className.replace(\"show\", \"\");\r\n        }, 3000);\r\n    }\r\n\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                {\r\n                    // --------- If the user has no favorite vacations --------- //\r\n                    this.state.favoriteVacations.length > 0\r\n                    &&\r\n                    \r\n                        <div className=\"favoriteVacationsSection\">\r\n\r\n                            <div className=\"headerContainer\">\r\n                                <h2 className=\"sharp-text favoritesHeader\">Your Favorite Vacations</h2>\r\n                            </div>\r\n\r\n                            <div className=\"favoriteVacations\">\r\n\r\n                                {/* ---------- All Vacations Cards, Using a Designated 'Favorite Vacation' Component ---------- */}\r\n\r\n                                {this.state.favoriteVacations.map( (vacation : Vacation, index : number) => \r\n                                    <FavoriteVacationComponent key={index} vacation={vacation} OnUserDislikeClick={this.OnUserDislikeClick} />\r\n                                )}\r\n                            </div>\r\n                        </div>\r\n                }\r\n\r\n                {/* The User's Snackbar Error Indication */}\r\n                <div id=\"snackbar\"></div>\r\n\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default withRouter(FavoriteVacations);"]},"metadata":{},"sourceType":"module"}